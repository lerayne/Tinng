<polymer-element name="nodelist-base" attributes="nodes">
	<template>

		<style>
			:host {
				max-width: 700px;
				overflow-y: scroll;
			}

			:host([loading]) {
				background: url(../../../stock/images/throbber_big.gif) no-repeat center center;
			}
		</style>

	</template>

	<script>
		Polymer({

			clientId:0,

			sortField:'created',
			sortOrder:'desc',

			publish:{
				loading: {value: false, reflect: true},
				loaded: {value: false, reflect: true}
			},

			observe:{
				sortField:'sortSelf',
				sortOrder:'sortSelf'
			},


			created:function(){
				this.nodes = [];
			},


			// сортировка по поданным параметрам (удобна для декларативного фильтра, который пока не работает)
			sort:function(input, sortField, sortOrder){

				var array = _.sortBy(input, sortField)
				if (sortOrder == 'desc') array.reverse();

				return array;
			},


			sortSelf:function(){

				this.nodes = this.sort(this.nodes, this.sortField, this.sortOrder)
			},

			// добавляет, обновляет, или удаляет ноду
			processItem:function(data){

				// если у объекта нет id - присваеваем ему локальный клиентский id
				if (!data.id) data.id = 'c'+(this.clientId++);

				// находим индекс нужного элемента по id
				var existingItemIndex = _(this.nodes).findIndex({id: data.id});


				if (existingItemIndex == -1) {
					// если такого элемента нет - добавляем новый элемент в коллекцию

					// установка this.sortOrder в последний параметр актуальна только для сортировки по времени
					var sortIndex = t.funcs.getSortIndex(this.nodes, data, this.sortField, this.sortOrder, this.sortOrder)

					// вставляем новый элемент в нужное место
					if (sortIndex == this.nodes.length) {
						this.nodes.push(data)
					} else {
						this.nodes.splice(sortIndex, 0, data);
					}

				} else {
					if (+data.deleted) {
						// если есть и удален - удаляем из коллекции
						this.nodes.splice(existingItemIndex, 1)
					} else {
						// иначе - мягко обновляем существующий элемент (иначе пересоздается нода, обнуляя все свои свойства)
						// впрочем, теги и другие вложенные объекты сейчас пересоздаются, так что возможно (todo) создать функцию рекурсивного мягкого обновления
						for (var key in data) {
							this.nodes[existingItemIndex][key] = data[key];
						}
					}
				}
			},

			isAtBottom:function(){
				return this.scrollHeight - (this.scrollTop + this.offsetHeight) == 0;
			},

			isAtTop:function(){
				return this.scrollTop == 0;
			},

			toBottom: function(){
				this.$.scroll.scrollIntoView(false)
			},

			toTop: function(){
				this.$.scroll.scrollIntoView(true)
			}
		})
	</script>
</polymer-element>