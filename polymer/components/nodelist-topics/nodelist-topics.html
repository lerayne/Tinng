<link rel="import" href="../nodelist-base/nodelist-base.html">
<link rel="import" href="../node-topic/node-topic.html">

<polymer-element name="nodelist-topics" extends="nodelist-base" on-tag-select="{{tagSelect}}">

	<template>
		<style>
			#scroll {
				padding: 15px 15px 1px 15px;
			}
		</style>

		<core-signals
			on-core-signal-topic-select="{{topicSelect}}"
		></core-signals>

		<div id="scroll">
			<template repeat="{{ node in nodes }}">

				<node-topic data="{{node}}"></node-topic>

			</template>
		</div>

	</template>

	<script>
		Polymer({

			sortField: 'updated',


			created: function () {

				this.super();

				this.subscribe();

				$(window).on('topics-main-update', this.parseTopics.bind(this))
			},


			topicSelect:function(event, detail){
				var topicData = detail.topic;
				var initiator = detail.sender;

				_(this.$.scroll.children).each(function(node){
					node.selected = false;
				})

				var node = this.findNode(topicData.id);

				if (typeof node != 'undefined') {
					this.findNode(topicData.id).selected = true;

					// todo - проверить!
					if (initiator.nodeName.toLowerCase() != 'node-topic') {
						node.scrollIntoView()
					}
				}
			},

			findNode:function(id){
				return  _(this.$.scroll.children).find({ID: +id})



				//if (typeof selectedNode != 'undefined') selectedNode.scrollIntoView();
			},

			tagSelect:function(event, detail, sender){
				console.log('tagSelect\n', event, '\n', detail, '\n', sender)
			},

			subscribe: function () {

				t.connection.subscribe({
					subscriber: this,
					feedName: 'topics-main',
					feed: {
						feed: 'topics'
					}
				});
			},

			/*processItem: function (data) {

				this.super(arguments);

			},*/


			parseTopics: function (event, topics) {

				if (!this.nodes.length) {
					// если это первичная загрузка

					// если мы заполняем массив первый раз - нужно его отсортировать
					this.nodes = this.sort(topics, this.sortField, this.sortOrder);

				} else {
					// если в массиве уже есть ноды

					for (var i = 0; i < topics.length; i++) {
						//processItem соблюдает сортировку самостоятельно
						this.processItem(topics[i])
					}

					// todo - нужно либо отключить соблюдение сортировки в processItem, либо сделать условие на выполнение sortSelf
					// (было обновление) иначе - двойная работа. А еще лучше - сначала, если есть обновления, А ТАКЖЕ если от
					// обновлений может зависеть порядок - обновить и отсортировать, а затем добавить/удалить с само-сортировкой.
					// Чтобы понять, нужна ли сортировка - можно проверять, изменилось ли поле, по которому сортируем ;)
					this.sortSelf();
				}
			}
		})
	</script>

</polymer-element>