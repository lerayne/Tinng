/**
 * Created with JetBrains PhpStorm.
 * User: M. Yegorov
 * Date: 11/14/13
 * Time: 5:38 PM
 * To change this template use File | Settings | File Templates.
 */

// при первом вызове присваивает id вызывавшему объекту и заносит его в список. При повторном вызове просто возвращает id
unit.subscriberId()

// подписывается на изменения, привязывает их к id подписчика. Повторный вызов перезаписывает подписку поверх
t.connection.subscribe( unit.subscriberId(), {
	feed:'topics',
	filter:{tags:'1|2'},
	sort:'updated',
	reverse_sort:true
});

// выборочно изменяет переметры подписки
t.connection.rescribe( unit.subscriberId(), {
	sort:'alphabet'
})

// снимает подписку с объекта
t.connection.unscribe( unit.subscriberId());

// посылает на сервер запрос на изменение данных. Не зависит от подписок, поэтому должен содержать подробные данные
t.connection.write({
	action:'new_message',
	topic:700,
	message:'это мой новый пост!'
})

/*
* все пересетры должны принимать аргументы не жестко, так как в будущем может понадобиться еще как минимум один элемент -
* идентификатор самой подписки. Это на тот случай, если я захочу дать подписчику возможность подписываться на несколько
* фидов одновременно. Сейчас принят закон, что у одного подписчика может быть только один фид и он однозначно
* идентифицируется по id подписчика
* */

/*
* когда передаются параметры для загрузки сообщений, можно передать кол-во сообщений, или дату, начиная с которой их
* нужно загрузить. При этом дата имеет преимущество, т.е. если она передана - кол-во не учитывается. Таким образом,
* если мы уже один раз запросили вычисление этой даты, основанное на кол-ве сообщений (через другую подписку) и передали
* в запрос - ответ выдается по дате.
* */

/*
* Проблема: как организовать ситсему подписок?
* Вариант 1: каждый модуль может подписаться на несколько "фидов", но каждый фид является плоским списком, или ассоц. массивом.
* Проблемы: 1) при таком действии как подгрузка новых сообщений нужно изменить не менее 3 подписок: свойства темы (ассоц.),
* 			собственно сообщения (список), и онлайн-статус юзеров, являющихся авторами сообщений в данном срезе постов (список).
* 			При этом данные фиды не являются абсолютно независимыми - например список сообщений и юзеров зависит от данных,
* 			приходящих по подписке на свойства темы. Пока всё работает на шорт-полле - все хорошо, потому что все подписки
* 			возвращаются одновременно. Но как только мы переходим на сокет - начинаются проблемы, потому что по событию
* 			"догрузить еще сообщений" мы изменяем 3 подписки, которые независимо друг от друга уходят на сервер и ответы
*	 		от них приходят так же независимо.
*
*	 		Возможные решения: группировка подписок по модулю. Устанавливается правило, по которому клиент всегда отправляет
*			изменения подписок по одному модулю одним пакетом, соответственно и сервер группирует ответы.
*
*			2) Поскольку на сервере, даже в варианте шорт-полла, подписки обрабатываются независимо, может возникнуть ситуация,
*			когда одни и те же данные для обслуживания одного модуля достаются два раза. Это не только неэкономно в плане ресурсов
*			БД, но и может стать проблемой, если подписки обработаются не в том порядке. Ладно, допустим опасность измнения
*			данных между запросами решается транзакциями, но в любом случае такие двойные запросы не должны записывать данных, а
*			они записывают - например данные о прочитанности темы
*
* Вариант 2: каждый фид может содержать несколько типов данных, но один модуль может подписаться только на один фид.
* Проблемы: 1) В таком случае протокол получается негибким и вообще вряд ли может называться полноценной API, так как мы делаем
* 			фиксированный набор фидов для каждого модуля.
* */